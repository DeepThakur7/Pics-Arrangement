
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Compress, Arrange & Export Images to Excel</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- ExcelJS for creating .xlsx in the browser -->
  https://cdn.jsdelivr.net/npm/exceljs@4.4.0/dist/exceljs.min.js</script>
  <!-- FileSaver for saving the Excel file -->
  https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js</script>
  <!-- SortableJS for drag-and-drop ordering -->
  https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js</script>

  <style>
    :root {
      --accent: #2563eb;
      --accent-2: #1e40af;
      --bg: #f8fafc;
      --border: #e5e7eb;
      --text: #0f172a;
      --muted: #64748b;
    }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      margin: 0;
      background: var(--bg);
      color: var(--text);
    }
    header {
      padding: 20px 24px;
      border-bottom: 1px solid var(--border);
      background: #fff;
      position: sticky; top: 0; z-index: 10;
    }
    h1 { margin: 0 0 8px; font-size: 20px; }
    .sub { color: var(--muted); font-size: 14px; }
    main { padding: 24px; max-width: 1200px; margin: 0 auto; }
    .panel {
      background: #fff; border: 1px solid var(--border); border-radius: 12px; padding: 16px;
      box-shadow: 0 1px 2px rgba(0,0,0,.04);
    }

    .controls {
      display: grid; grid-template-columns: repeat(3, minmax(200px, 1fr)); gap: 12px;
      margin: 16px 0;
    }
    .control label { font-size: 13px; color: var(--muted); display: block; margin-bottom: 6px; }
    .control input[type="number"],
    .control input[type="range"],
    .control select {
      width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 8px; background: #fff;
    }
    .buttons { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 8px; }
    .btn {
      appearance: none; border: 1px solid var(--border); background: #fff; padding: 10px 14px;
      border-radius: 10px; cursor: pointer; font-weight: 600; color: var(--text);
    }
    .btn.primary {
      background: var(--accent); color: #fff; border-color: var(--accent);
    }
    .btn.primary:hover { background: var(--accent-2); }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }

    .dropzone {
      border: 2px dashed var(--border);
      border-radius: 12px;
      padding: 20px; text-align: center; color: var(--muted); background: #fafafa;
    }
    .dropzone.dragover { border-color: var(--accent); background: #eef2ff; color: var(--accent-2); }
    .dropzone input { display: none; }
    .dropzone .title { font-weight: 600; margin-bottom: 8px; }
    .dropzone .hint { font-size: 13px; }

    .grid {
      display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 12px;
      margin-top: 16px;
    }
    .tile {
      border: 1px solid var(--border); border-radius: 10px; overflow: hidden; background: #fff;
      display: flex; flex-direction: column;
    }
    .thumb-wrap { aspect-ratio: 1 / 1; background: #f3f4f6; display: flex; align-items: center; justify-content: center; }
    .thumb-wrap img { max-width: 100%; max-height: 100%; display: block; }
    .meta {
      padding: 8px; font-size: 12px; color: var(--muted);
      display: grid; gap: 6px;
    }
    .name { color: var(--text); font-weight: 600; font-size: 12px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .stats { display: flex; gap: 10px; flex-wrap: wrap; }
    .handle {
      padding: 8px; font-size: 12px; color: var(--muted); border-top: 1px dashed var(--border);
      background: #fafafa; text-align: center; cursor: grab;
    }
    .footer-note { font-size: 12px; color: var(--muted); margin-top: 12px; }
    .hidden { display: none !important; }
    .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); white-space: nowrap; border: 0; }
  </style>
</head>
<body>
  <header>
    <h1>Compress, Arrange & Export Images to Excel</h1>
    <div class="sub">Select photos → compress client-side → drag to arrange → export to .xlsx with thumbnails & metadata.</div>
  </header>

  <main>
    <section class="panel">
      <div class="controls">
        <div class="control">
          <label for="maxWidth">Max width (px)</label>
          <input id="maxWidth" type="number" min="64" max="8000" step="10" value="1200" />
        </div>
        <div class="control">
          <label for="quality">JPEG quality: <span id="qualityValue">0.8</span></label>
          <input id="quality" type="range" min="0.1" max="1" step="0.05" value="0.8" />
        </div>
        <div class="control">
          <label for="thumbHeight">Excel thumbnail height (px)</label>
          <input id="thumbHeight" type="number" min="60" max="600" step="10" value="160" />
        </div>
      </div>

      <div class="buttons">
        <button id="selectBtn" class="btn">Select images</button>
        <button id="compressBtn" class="btn">Compress</button>
        <button id="clearBtn" class="btn">Clear</button>
        <button id="exportBtn" class="btn primary" disabled>Export to Excel</button>
      </div>

      <div id="dropzone" class="dropzone" aria-label="Image dropzone">
        <div class="title">Drag & drop images here</div>
        <div class="hint">or click <strong>Select images</strong> above. Accepted: JPG, PNG, WebP, GIF (first frame).</div>
        <input id="fileInput" type="file" accept="image/*" multiple />
      </div>

      <div id="grid" class="grid hidden" aria-live="polite" aria-relevant="additions removals"></div>
      <div id="note" class="footer-note hidden">Tip: Drag the tiles using the handle to set the final order before exporting.</div>
    </section>
  </main>

  <script>
    // State for selected & processed images
    const state = {
      items: [] // {id, file, name, originalBytes, originalDataURL, compressedDataURL, compressedBytes, width, height}
    };

    const els = {
      fileInput: document.getElementById('fileInput'),
      dropzone: document.getElementById('dropzone'),
      selectBtn: document.getElementById('selectBtn'),
      compressBtn: document.getElementById('compressBtn'),
      clearBtn: document.getElementById('clearBtn'),
      exportBtn: document.getElementById('exportBtn'),
      grid: document.getElementById('grid'),
      note: document.getElementById('note'),
      maxWidth: document.getElementById('maxWidth'),
      quality: document.getElementById('quality'),
      qualityValue: document.getElementById('qualityValue'),
      thumbHeight: document.getElementById('thumbHeight'),
    };

    // Update quality display
    els.quality.addEventListener('input', () => {
      els.qualityValue.textContent = Number(els.quality.value).toFixed(2);
    });

    // File selection
    els.selectBtn.addEventListener('click', () => els.fileInput.click());
    els.fileInput.addEventListener('change', (e) => handleFiles(e.target.files));

    // Drag & drop
    ['dragenter', 'dragover'].forEach(evt => {
      els.dropzone.addEventListener(evt, (e) => {
        e.preventDefault(); e.stopPropagation();
        els.dropzone.classList.add('dragover');
      });
    });
    ['dragleave', 'drop'].forEach(evt => {
      els.dropzone.addEventListener(evt, (e) => {
        e.preventDefault(); e.stopPropagation();
        els.dropzone.classList.remove('dragover');
      });
    });
    els.dropzone.addEventListener('drop', (e) => {
      const dt = e.dataTransfer;
      if (dt && dt.files && dt.files.length) handleFiles(dt.files);
    });

    // Clear
    els.clearBtn.addEventListener('click', () => {
      state.items = [];
      render();
    });

    // Compress action
    els.compressBtn.addEventListener('click', async () => {
      if (!state.items.length) return;
      const maxW = parseInt(els.maxWidth.value, 10) || 1200;
      const qual = parseFloat(els.quality.value) || 0.8;

      for (let item of state.items) {
        try {
          const out = await compressImageFile(item.file, { maxWidth: maxW, quality: qual });
          item.compressedDataURL = out.dataURL;
          item.compressedBytes = out.bytes;
          item.width = out.width;
          item.height = out.height;
        } catch (err) {
          console.error('Compression error', err);
        }
      }
      render();
      els.exportBtn.disabled = false;
    });

    // Export to Excel
    els.exportBtn.addEventListener('click', async () => {
      if (!state.items.length) return;
      const thumbH = parseInt(els.thumbHeight.value, 10) || 160;
      try {
        const wb = new ExcelJS.Workbook();
        wb.created = new Date();
        wb.modified = new Date();
        wb.properties = { title: 'Images (Compressed & Arranged)', subject: 'Images', company: 'Export Tool' };

        const ws = wb.addWorksheet('Images');

        // Header row
        ws.addRow(['File name', 'Original size (KB)', 'Compressed size (KB)', 'Dimensions (W×H)', 'Preview']);
        ws.getRow(1).font = { bold: true };
        ws.columns = [
          { header: 'File name', key: 'name', width: 40 },
          { header: 'Original size (KB)', key: 'origKB', width: 18 },
          { header: 'Compressed size (KB)', key: 'compKB', width: 18 },
          { header: 'Dimensions (W×H)', key: 'dims', width: 18 },
          { header: 'Preview', key: 'preview', width: 20 },
        ];

        // Add rows + images
        for (let i = 0; i < state.items.length; i++) {
          const item = state.items[i];
          const rowIdx = i + 2; // row 1 = header
          const origKB = bytesToKB(item.originalBytes);
          const compKB = item.compressedBytes ? bytesToKB(item.compressedBytes) : '';
          const dims = item.width && item.height ? `${item.width}×${item.height}` : '';

          ws.addRow([item.name, origKB, compKB, dims, '']);

          // Attach image (prefer compressedDataURL; fallback to original)
          const dataURL = item.compressedDataURL || item.originalDataURL;
          const imgId = wb.addImage({ base64: dataURL, extension: guessExtensionFromDataURL(dataURL) });

          // Compute image display size: keep aspect; use given thumbnail height
          const { width: w, height: h } = await measureDataURL(dataURL);
          const aspect = w / h;
          const displayH = thumbH; // px
          const displayW = Math.round(displayH * aspect);

          // Set row height to match
          ws.getRow(rowIdx).height = pxToExcelRowHeight(displayH);

          // Position the image around column E (index 5), row rowIdx
          // Note: ExcelJS uses "tl" (top-left) in terms of column & row (0-indexed within the cell grid)
          // We’ll anchor near col 4.5 so it looks centered within the "Preview" column.
          ws.addImage(imgId, {
            tl: { col: 4.2, row: rowIdx - 1 + 0.15 },
            ext: { width: displayW, height: displayH },
            editAs: 'oneCell'
          });
        }

        const buffer = await wb.xlsx.writeBuffer();
        const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
        const stamp = new Date().toISOString().slice(0,19).replace(/[:T]/g,'-');
        saveAs(blob, `Images_Compressed_Arranged_${stamp}.xlsx`);
      } catch (err) {
        console.error(err);
        alert('Export failed. See console for details.');
      }
    });

    // Initialize Sortable grid
    new Sortable(els.grid, {
      animation: 150,
      handle: '.handle',
      onEnd: (evt) => {
        // Reorder state.items based on grid DOM order
        const newOrder = Array.from(els.grid.querySelectorAll('.tile')).map(t => t.dataset.id);
        state.items.sort((a,b) => newOrder.indexOf(String(a.id)) - newOrder.indexOf(String(b.id)));
        render(); // re-render to ensure order is reflected
      }
    });

    // Handle files
    function handleFiles(fileList) {
      const files = Array.from(fileList).filter(f => f.type.startsWith('image/'));
      if (!files.length) return;
      const startId = state.items.length ? Math.max(...state.items.map(i => i.id)) + 1 : 1;
      let idCounter = startId;

      Promise.all(files.map(f => loadImageAsDataURL(f)))
        .then(results => {
          for (let res of results) {
            state.items.push({
              id: idCounter++,
              file: res.file,
              name: res.file.name,
              originalBytes: res.file.size,
              originalDataURL: res.dataURL,
              compressedDataURL: null,
              compressedBytes: null,
              width: res.width,
              height: res.height
            });
          }
        })
        .then(() => {
          render();
          // Enable compress; export only after compression (optional)
          els.compressBtn.disabled = state.items.length === 0;
        })
        .catch(err => console.error('Load error', err));
    }

    // Rendering
    function render() {
      if (!state.items.length) {
        els.grid.classList.add('hidden');
        els.note.classList.add('hidden');
        els.exportBtn.disabled = true;
        els.compressBtn.disabled = true;
        return;
      }
      els.grid.classList.remove('hidden');
      els.note.classList.remove('hidden');
      els.compressBtn.disabled = false;

      els.grid.innerHTML = '';
      for (let item of state.items) {
        const tile = document.createElement('div');
        tile.className = 'tile';
        tile.dataset.id = String(item.id);

        const thumbWrap = document.createElement('div');
        thumbWrap.className = 'thumb-wrap';
        const img = document.createElement('img');
        img.loading = 'lazy';
        img.src = item.compressedDataURL || item.originalDataURL;
        thumbWrap.appendChild(img);

        const meta = document.createElement('div');
        meta.className = 'meta';
        const name = document.createElement('div');
        name.className = 'name';
        name.title = item.name;
        name.textContent = item.name;

        const stats = document.createElement('div');
        stats.className = 'stats';
        const orig = document.createElement('div');
        orig.textContent = `Original: ${bytesToKB(item.originalBytes)} KB`;
        const comp = document.createElement('div');
        comp.textContent = item.compressedBytes ? `Compressed: ${bytesToKB(item.compressedBytes)} KB` : 'Compressed: —';
        const dims = document.createElement('div');
        dims.textContent = (item.width && item.height) ? `Size: ${item.width}×${item.height}` : 'Size: —';

        stats.appendChild(orig);
        stats.appendChild(comp);
        stats.appendChild(dims);

        meta.appendChild(name);
        meta.appendChild(stats);

        const handle = document.createElement('div');
        handle.className = 'handle';
        handle.textContent = 'Drag to reorder';

        tile.appendChild(thumbWrap);
        tile.appendChild(meta);
        tile.appendChild(handle);

        els.grid.appendChild(tile);
      }
      // Enable export if at least one image present (even without compression)
      els.exportBtn.disabled = state.items.length === 0;
    }

    // Helpers

    function bytesToKB(bytes) {
      return Math.round((bytes / 1024) * 10) / 10;
    }

    function loadImageAsDataURL(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = async () => {
          const dataURL = reader.result;
          try {
            const dims = await measureDataURL(dataURL);
            resolve({ file, dataURL, width: dims.width, height: dims.height });
          } catch (e) { reject(e); }
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    function measureDataURL(dataURL) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve({ width: img.naturalWidth, height: img.naturalHeight });
        img.onerror = reject;
        img.src = dataURL;
      });
    }

    function compressImageFile(file, { maxWidth = 1200, quality = 0.8 } = {}) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
          const srcDataURL = reader.result;
          const img = new Image();
          img.onload = () => {
            const scale = Math.min(1, maxWidth / img.naturalWidth);
            const targetW = Math.round(img.naturalWidth * scale);
            const targetH = Math.round(img.naturalHeight * scale);

            const canvas = document.createElement('canvas');
            canvas.width = targetW; canvas.height = targetH;
            const ctx = canvas.getContext('2d');

            // High-quality scaling
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.drawImage(img, 0, 0, targetW, targetH);

            // Output to JPEG (good for thumbnails & Excel embedding)
            const outDataURL = canvas.toDataURL('image/jpeg', quality);
            const bytes = dataURLSize(outDataURL);

            resolve({ dataURL: outDataURL, bytes, width: targetW, height: targetH });
          };
          img.onerror = reject;
          img.src = srcDataURL;
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    function dataURLSize(dataURL) {
      // Base64 length to bytes
      const base64 = dataURL.split(',')[1] || '';
      const padding = (base64.match(/=+$/) || [''])[0].length;
      return Math.floor(base64.length * 3 / 4) - padding;
    }

    function guessExtensionFromDataURL(dataURL) {
      const m = /^data:image\/(png|jpeg|jpg|webp)/i.exec(dataURL);
      if (!m) return 'jpeg';
      const ext = m[1].toLowerCase();
      return ext === 'jpg' ? 'jpeg' : ext;
    }

    // Excel row height is roughly in points; 1 point ≈ 1.333 px. ExcelJS expects points.
    function pxToExcelRowHeight(px) {
      return Math.round(px * 0.75); // points = px * 0.75
    }
  </script>
</body>
</html>
